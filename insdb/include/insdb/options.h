/*
 * Original Code Copyright (c) 2011 The LevelDB Authors. All rights reserved.
 * Use of the original source code is governed by a BSD-style license that can be
 * found in the LICENSE file. See the AUTHORS file for names of contributors.
 *
 * Modifications made 2019
 * Modifications Copyright (c) 2019, Samsung Electronics.
 *
 * Architect    : Heekwon Park(heekwon.p@samsung.com), Yangseok Ki(yangseok.ki@samsung.com)
 * Authors      : Heekwon Park, Ilgu Hong, Hobin Lee
 *
 * This modified version is distributed under a BSD-style license that can be
 * found in the LICENSE.insdb file  
 *                    
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  
 */


#ifndef STORAGE_INSDB_INCLUDE_OPTIONS_H_
#define STORAGE_INSDB_INCLUDE_OPTIONS_H_

#include <stdint.h>
#include <stddef.h>
#include "insdb/export.h"
#include "insdb/status.h"
#include <vector>

namespace insdb {

    class Cache;
    class Comparator;
    class AssociativeMergeOperator;
    class Env;
    class FilterPolicy;
    class Logger;
    class Snapshot;

    // DB contents are stored in a set of blocks, each of which holds a
    // sequence of key,value pairs.  Each block may be compressed before
    // being stored in a file.  The following enum describes which
    // compression method (if any) is used to compress a block.
    enum CompressionType {
        // NOTE: do not change the values of existing entries, as these are
        // part of the persistent format on disk.
        kNoCompression     = 0x0,
        kSnappyCompression = 0x1
    };

    enum EntryType {
      kEntryPut,
      kEntryDelete,
      kEntrySingleDelete,
      kEntryMerge,
      kEntryOther,
    };

    typedef Status (*AddUserKeyCallback)(const Slice &key,
                         Slice &value,
                         EntryType type,
                         uint64_t seq,
                         uint64_t file_size,
                         uint16_t col_id,
                         void *context);

    typedef Status (*FlushCallback)(
                         uint16_t col_id,
                         void *context);

    // Options to control the behavior of a database (passed to DB::Open)
    extern uint64_t cache_size_change;
    struct INSDB_EXPORT Options {
        // -------------------
        // Parameters that affect behavior

        // Comparator used to define the order of keys in the table.
        // Default: a comparator that uses lexicographic byte-wise ordering
        //
        // REQUIRES: The client must ensure that the comparator supplied
        // here has the same name and orders keys *exactly* the same as the
        // comparator provided to previous open calls on the same DB.
        const Comparator* comparator;

        // REQUIRES: The client must provide a merge operator if Merge operation
        // needs to be accessed. Calling Merge on a DB without a merge operator
        // would result in Status::NotSupported. The client must ensure that the
        // merge operator supplied here has the same name and *exactly* the same
        // semantics as the merge operator provided to previous open calls on
        // the same DB. The only exception is reserved for upgrade, where a DB
        // previously without a merge operator is introduced to Merge operation
        // for the first time. It's necessary to specify a merge operator when
        // opening the DB in this case.
        // Default: nullptr
        AssociativeMergeOperator* merge_operator;

        // If true, the database will be created if it is missing.
        // Default: false
        bool create_if_missing;

        // If true, an error is raised if the database already exists.
        // Default: false
        bool error_if_exists;

        // If true, the implementation will do aggressive checking of the
        // data it is processing and will stop early if it detects any
        // errors.  This may have unforeseen ramifications: for example, a
        // corruption of one DB entry may cause a large number of entries to
        // become unreadable or for the entire DB to become unopenable.
        // Default: false
        bool paranoid_checks;

        // Use the specified object to interact with the environment,
        // e.g. to read/write files, schedule background work, etc.
        // Default: Env::Default()
        Env* env;

        // Any internal progress/error information generated by the db will
        // be written to info_log if it is non-NULL, or to a file stored
        // in the same directory as the DB contents if info_log is NULL.
        // Default: NULL
        Logger* info_log;

        // -------------------
        // Parameters that affect performance

        // Amount of data to build up in memory (backed by an unsorted log
        // on disk) before converting to a sorted on-disk file.
        //
        // Larger values increase performance, especially during bulk loads.
        // Up to two write buffers may be held in memory at the same time,
        // so you may wish to adjust this parameter to control memory usage.
        // Also, a larger write buffer will result in a longer recovery time
        // the next time the database is opened.
        //
        // Default: 4MB
        size_t write_buffer_size;

        // Number of open files that can be used by the DB.  You may need to
        // increase this if your database has a large working set (budget
        // one open file per 2MB of working set).
        //
        // Default: 1000
        int max_open_files;

        // Control over blocks (user data is stored in a set of blocks, and
        // a block is the unit of reading from disk).

        // If non-NULL, use the specified cache for blocks.
        // If NULL, insdb will automatically create and use an 8MB internal cache.
        // Default: NULL
        Cache* block_cache;

        // Approximate size of user data packed per block.  Note that the
        // block size specified here corresponds to uncompressed data.  The
        // actual size of the unit read from disk may be smaller if
        // compression is enabled.  This parameter can be changed dynamically.
        //
        // Default: 4K
        size_t block_size;

        // Number of keys between restart points for delta encoding of keys.
        // This parameter can be changed dynamically.  Most clients should
        // leave this parameter alone.
        //
        // Default: 16
        int block_restart_interval;

        // Leveldb will write up to this amount of bytes to a file before
        // switching to a new one.
        // Most clients should leave this parameter alone.  However if your
        // filesystem is more efficient with larger files, you could
        // consider increasing the value.  The downside will be longer
        // compactions and hence longer latency/performance hiccups.
        // Another reason to increase this parameter might be when you are
        // initially populating a large database.
        //
        // Default: 2MB
        size_t max_file_size;

        // Compress blocks using the specified compression algorithm.  This
        // parameter can be changed dynamically.
        //
        // Default: kSnappyCompression, which gives lightweight but fast
        // compression.
        //
        // Typical speeds of kSnappyCompression on an Intel(R) Core(TM)2 2.4GHz:
        //    ~200-500MB/s compression
        //    ~400-800MB/s decompression
        // Note that these speeds are significantly faster than most
        // persistent storage speeds, and therefore it is typically never
        // worth switching to kNoCompression.  Even if the input data is
        // incompressible, the kSnappyCompression implementation will
        // efficiently detect that and will switch to uncompressed mode.
        CompressionType compression;

        // EXPERIMENTAL: If true, append to existing MANIFEST and log files
        // when a database is opened.  This can significantly speed up open.
        //
        // Default: currently false, but may become true later.
        bool reuse_logs;

        // Prefix detection
        bool prefix_detection;

        // disable cache
        bool disable_cache;

        // disable IO size check
        bool disable_io_size_check;

        // share iterator pad
        bool iterpad_share;

        // keep written key blocks in memory
        bool keep_written_keyblock;

        // allow table eviction
        bool table_eviction;

        // If non-NULL, use the specified filter policy to reduce disk reads.
        // Many applications will benefit from passing the result of
        // NewBloomFilterPolicy() here.
        //
        // Default: NULL
        const FilterPolicy* filter_policy;

        /**
          InsDB will keep user data on the cache up to this amount of bytes.
          User can adjust this value. But if this amount less than default,
          InSDB will set default rather than user supplied size.

          Default: 2GB.
         */

        size_t max_cache_size;

        /**
          InSDB write worker number, it will configuable by user.

Default: 4.
*/
        int num_write_worker;

        /**
          InSDB Column Family's Colum count;
          Default 1 --> column ID 0;
          */
        int num_column_count;

        // Deprecated
        size_t sktable_low_key_count;
        // Deprecated
        size_t sktable_high_key_count;

        /**
          InSDB max request size;
          Default 32k.
          */
        int max_request_size;

        /**
          InSDB max user key size;
          Default 16B.
          */
        int max_key_size;

        /**
          InSDB max table size;
          Default 512B
          */
        int max_table_size;

        /**
          InSDB max prefetched user value size.
          Default 1G
          */
        size_t max_uval_prefetched_size;
        /**
          InSDB max iterator buffered user value size.
          Default 1G
          */
        size_t max_uval_iter_buffered_size;
        /**
          InSDB max cache size for user value.
          Default 1G
          */
        size_t max_uval_cache_size;

        /**
         KV SSD device name
         */
        std::vector<std::string> kv_ssd;

        /**
          Average approximate key size
         */
        size_t approx_key_size;

        /**
          Average approximate value size
         */
        size_t approx_val_size;

        /**
          Average approximate table encoding effectiveness
         */
        uint16_t approx_table_encoding_factor;

        /**
          iterator prefetch hint
         */
        uint32_t iter_prefetch_hint;

        /**
          random prefetch hint
         */
        uint32_t random_prefetch_hint;

        /**
          Max threshold size to flush
          the accumated size of requested user value exceeds this value, trigger SKTable flush.
          */
        size_t flush_threshold;
        /**
          Minimum update count for triggering SKTableMem flush
          */
        uint32_t min_update_cnt_table_flush;
        /**
          Use for congestion control user put request.
          User request will wait pending request is bigger than kSlowdownTrigger.
          */
        uint32_t slowdown_trigger;
        /**
          Device Data align size for key-value
          */
        uint32_t align_size;
        /**
          table split prefix size in bits
         */
        int split_prefix_bits;
        /**
          callback for user key operations
         */
        bool use_compact_key;
        AddUserKeyCallback AddUserKey;
        void *AddUserKeyContext;
        FlushCallback Flush;
        void *FlushContext;

        // Create an Options object with default values for all fields.
        Options();
    };

    // Options that control read operations
    struct INSDB_EXPORT ReadOptions {
        // If true, all data read from underlying storage will be
        // verified against corresponding checksums.
        // Default: false
        bool verify_checksums;

        // Should the data read for this iteration be cached in memory?
        // Callers may wish to set this field to false for bulk scans.
        // Default: true
        bool fill_cache;

        // If "snapshot" is non-NULL, read as of the supplied snapshot
        // (which must belong to the DB that is being read and which must
        // not have been released).  If "snapshot" is NULL, use an implicit
        // snapshot of the state at the beginning of this read operation.
        // Default: NULL
        const Snapshot* snapshot;

        ReadOptions()
            : verify_checksums(false),
            fill_cache(true),
            snapshot(NULL) {
            }
    };

    // Options that control write operations
    struct INSDB_EXPORT WriteOptions {
        // If true, the write will be flushed from the operating system
        // buffer cache (by calling WritableFile::Sync()) before the write
        // is considered complete.  If this flag is true, writes will be
        // slower.
        //
        // If this flag is false, and the machine crashes, some recent
        // writes may be lost.  Note that if it is just the process that
        // crashes (i.e., the machine does not reboot), no writes will be
        // lost even if sync==false.
        //
        // In other words, a DB write with sync==false has similar
        // crash semantics as the "write()" system call.  A DB write
        // with sync==true has similar crash semantics to a "write()"
        // system call followed by "fsync()".
        //
        // Default: false
        bool sync;

        uint64_t ttl;

        WriteOptions(): 
            sync(false),
            ttl(0){
            }
    };

    // Options that control flush operations
    struct FlushOptions {
      // If true, the flush will wait until the flush is done.
      // Default: true
      bool wait;

      FlushOptions() : wait(true) {}
    };

}  // namespace insdb

#endif  // STORAGE_INSDB_INCLUDE_OPTIONS_H_
